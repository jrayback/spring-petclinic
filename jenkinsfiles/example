#!/bin/env groovy

pipeline {
  agent none

  environment {
    IMAGE = "liatrio/petclinic-tomcat"
    SMOKETEST_PASS = 1
    MONITOR_PASS = 1
    SHORT_PAUSE = 1
    MED_PAUSE = 2
    LONG_PAUSE = 3
  }

  stages {
    stage ('Start') {
      steps{
        // send build started notification
        // TODO: there should be a notification script, in scm and put
        // a shared library so that notification configuration information
        // is abstracted from the Jenkinsfile. Since it's only Slack for now
        // this is sufficient
        slackSend (color: '#FFFF00', message: "STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
      }
    }
    stage('Pre-Build') {
      parallel {
        stage('Run Unit Tests') {
          agent any
          steps {
            sh "sleep '${env.LONG_PAUSE}'"
            echo "Unit tests PASS"
          }
        }
        stage('Check Style') {
          agent any
          steps {
            // Run some sort of linter. E.g. Checkstyle
            echo "Running Checkstyle..."
            sh "sleep '${env.SHORT_PAUSE}'"
            echo "Checkstyle PASS"
          }
        }
        stage('Code Analysis') {
          agent any
          steps {
            // Do additional static code analysis. E.g. FindBugs
            echo "Running FindBugs..."
            sh "sleep '${env.MED_PAUSE}'"
            echo "FindBugs PASS"
          }
        }
      }
    }
    stage('Build') {
      agent any
      steps {
        //***sh 'mvn clean install'
        echo "install"
      }
    }
    stage('Package') {
      agent any
      steps {
        script {
          if ( env.BRANCH_NAME == 'master' ) {
              pom = readMavenPom file: 'pom.xml'
              TAG = pom.version
          } else {
              TAG = env.BRANCH_NAME
          }
          //***sh "docker build -t ${env.IMAGE}:${TAG} ."
          echo "package"
        }
      }
    }
    // Deploy to ephemeral dev environment - in this case locally running
    // docker container
    stage('Deploy to Dev') {
      agent any
      steps {
        //***sh 'docker rm -f petclinic-tomcat-temp || true'
        //***sh "docker run -d -p 9966:8080 --name petclinic-tomcat-temp ${env.IMAGE}:${TAG}"
        // send a message to the channel that a dev environment is available
        slackSend (color: '#00FF00', message: "Dev environment for Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL}) available at http://localhost:9966/petclinic/")
      }
    }
    // Deploy to Test environment. In this case another docker container
    // could simulate this. Test environment could be ephemeral or permanent
    // but doesn't need to fully simulate prod environment.
    stage('Deploy to Test') {
      agent any
      steps {
        // Doing this above in deploy to dev...don't need to do it twice
        // sh 'docker rm -f petclinic-tomcat-temp || true'
        // sh "docker run -d -p 9966:8080 --name petclinic-tomcat-temp ${env.IMAGE}:${TAG}"
        echo "Deploying to test environment..."
        sh "sleep '${env.SHORT_PAUSE}'"
        echo "Deployed to test environment"
        // send a message to the channel that a dev environment is available
        slackSend (color: '#00FF00', message: "Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL}) deployed to Test: http://jmr.liatrio.petclinic.ngrok.io/petclinic/")
      }
    }
    stage('Validate') {
      parallel {
        stage('Smoke Tests') {
          agent any
          steps {
            // Run automated smoke tests
            // Basic functionality, fail fast
            echo "Running smoke tests..."
            sh "sleep '${env.MED_PAUSE}'"
            script {
              if( env.SMOKETEST_PASS == 1 ) {
                echo "Smoke tests PASS"
              } else {
                echo "Smoke tests FAIL"
                currentBuild.result = 'FAILURE'
                error('Smoke tests FAIL')
              }
            }
          }
        }
        stage('Acceptance Tests') {
          agent any
          steps {
            // Run automated acceptance tests
            // More comprehensive, look for regressions
            sh "sleep '${env.LONG_PAUSE}'"
          }
        }
      }
    }
    // Princess (E.g.) is Etsy's name for an environment that fully simulates prod
    // but is only internally accessible. Deploy here before prod.
    // This allows for any type of manual inspection required before going
    // to blue/green
    stage("Deploy to 'Princess'") {
      agent any
      steps {
        //sample dummy step
        sh "sleep '${env.SHORT_PAUSE}'"
      }
    }
    stage('Pre-Prod') {
      parallel {
        stage('UAT') {
          agent any
          steps {
            // Run User Acceptance Tests (automated or manual), E.g. Cucumber
            echo "Running Cucumber tests..."
            sh "sleep '${env.SHORT_PAUSE}'"
            echo "Cucumber tests PASS"
          }
        }
        stage('Security Sanity Check') {
          agent any
          steps {
            // Run basic security/pen tests, assumes internal princess environment
            // can be made to very closely emulate prod (firewalls, etc.)
            // Use maybe something proprietary like Nessus...
            echo "Running Nessus check..."
            sh "sleep '${env.MED_PAUSE}'"
            echo "Nessus check PASS"
          }
        }
        stage('Basic load test') {
          agent any
          steps {
            // Run basic load test, E.g. JMeter or Gattling
            echo "Running JMeter tests..."
            sh "sleep '${env.LONG_PAUSE}'"
            echo "JMeter test PASS"
          }
        }
      }
    }
    // When everything looks good in Princess, deploy to dark prod
    stage('Deploy to Dark Prod') {
      input {
        message "Deploy to prod?"
        ok "Yes"
      }
      agent any
      steps {
        //sample dummy step
        sh "sleep '${env.SHORT_PAUSE}'"
      }
    }
    stage('Cutover') {
      parallel {
        // Make dark prod light
        stage('Redirect Load Balancer') {
          agent any
          steps {
            echo "Load balancer now pointing a new light prod..."
          }
        }
        // Monitor http traffic in new light prod environment for a 
        // set period of time, if things start going awry, revert to previous
        // light prod and fail, otherwise succeed.
        stage('Monitor New Prod Environment') {
          agent any
          steps {
            echo 'Monitoring http traffic in new prod environment...'
            sh "sleep '${env.LONG_PAUSE}'"
            echo 'Traffic looks good!'
          }
        }
      }
    }
  }
  post { 
    aborted {
      slackSend (color: '#FF0000', message: "ABORTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
    }
    failure {
      slackSend (color: '#FF0000', message: "FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
    }
    success {
      slackSend (color: '#00FF00', message: "SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
    }
  }
}
