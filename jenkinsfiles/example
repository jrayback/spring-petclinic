#!/bin/env groovy

pipeline {
  agent none

  environment {
    IMAGE = "liatrio/petclinic-tomcat"
  }

  stages {
    stage ('Start') {
      steps{
        // send build started notification
        // TODO: there should be a notification script, in scm and put
        // a shared library so that notification configuration information
        // is abstracted from the Jenkinsfile. Since it's only Slack for now
        // this is sufficient
        slackSend (color: '#FFFF00', message: "STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
      }
    }
    stage('Commit') {
      stages {
        stage('Pre-Build') {
          parallel {
            stage('Run Unit Tests') {
              agent any
              steps {
                sh "sleep 7"
                echo "Unit tests PASS"
              }
            }
            stage('Check Style') {
              agent any
              steps {
                // Run some sort of linter. E.g. Checkstyle
                echo "Running Checkstyle..."
                sh "sleep 4"
                echo "Checkstyle PASS"
              }
            }
            stage('Code Analysis') {
              agent any
              steps {
                // Do additional static code analysis. E.g. FindBugs
                echo "Running FindBugs..."
                sh "sleep 10"
                echo "FindBugs PASS"
              }
            }
          }
        }
        stage('Build') {
          agent any
          steps {
            sh 'mvn clean install'
          }
        }
        stage('Package') {
          agent any
          steps {
            script {
              if ( env.BRANCH_NAME == 'master' ) {
                  pom = readMavenPom file: 'pom.xml'
                  TAG = pom.version
              } else {
                  TAG = env.BRANCH_NAME
              }
              sh "docker build -t ${env.IMAGE}:${TAG} ."
            }
          }
        }
        // Deploy to ephemeral dev environment
        // in this case I pause to let the developer manually inspect
        // before continuing...
        stage('Deploy to Dev') {
          steps {
            echo "Deploying to dev environment..."
            sh "sleep 3"
          }
        }
      }
    }
    stage('Acceptance'){
      input {
        message "Deploy to test?"
        ok "Yes"
      }
      // Deploy to Test environment. In this case the docker container
      // simulates this. Test environment could be ephemeral or permanent
      // but doesn't need to fully simulate prod environment.
      stage('Deploy to Test') {
        agent any
        steps {
          sh 'docker rm -f petclinic-tomcat-temp || true'
          sh "docker run -d -p 9966:8080 --name petclinic-tomcat-temp ${env.IMAGE}:${TAG}"
        }
      }
      stage('Smoke-Test') {
        agent any
        steps {
          // Run automated smoke tests
          sh 'sleep 4'
        }
      }
    }
    // Princess is Etsy's name for an environment that fully simulates prod
    // but is only internally accessible. Deploy here before prod.
    stage('Deploy to Princess') {
      agent any
      steps {
        //sample dummy step
        sh 'sleep 4'
      }
    }
    // JMR sample test to prove I can update the pipeline
    stage('Deploy to Prod') {
      input {
        message "Deploy to prod?"
        ok "Yes"
      }
      agent any
      steps {
        //sample dummy step
        sh 'sleep 5'
      }
    }
  }
  post { 
    aborted {
      slackSend (color: '#FF0000', message: "ABORTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
    }
    failure {
      slackSend (color: '#FF0000', message: "FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
    }
    success {
      slackSend (color: '#00FF00', message: "SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
    }
  }
}
